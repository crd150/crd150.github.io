---
title: "Lab 5: Spatial Data in R"
subtitle: <h4 style="font-style:normal">CRD 150 - Quantitative Methods in Community Research</h4>
author: <h4 style="font-style:normal">Professor Noli Brazil</h4>
date: <h4 style="font-style:normal">February 8, 2023</h4>
output: 
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    mathjax: local
    theme: cosmo
    code_folding: show
    self_contained: false
---



<style>
p.comment {
background-color: #DBDBDB;
padding: 10px;
border: 1px solid black;
margin-left: 25px;
border-radius: 5px;
font-style: normal;
}

.figure {
   margin-top: 20px;
   margin-bottom: 20px;
}

h1.title {
  font-weight: bold;
  font-family: Arial;  
}

h2.title {
  font-family: Arial;  
}

</style>


<style type="text/css">
#TOC {
  font-size: 13px;
  font-family: Arial;
}
</style>



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message = FALSE)
```

<br>

In this guide you will acquire the skills needed to process and present spatial data in R.  The objectives of the guide are as follows 


1. Understand how spatial data are processed in R
2. Learn basic data wrangling operations on spatial data
3. Learn how to make a map in R

This lab guide follows closely and supplements the material presented in Chapters 1, 2.1, 2.2, 8 and 9 in the textbook [Geocomputation with R](https://geocompr.robinlovelace.net/) (GWR) and class Handout 5.

<br>

<p class="comment">**Assignment 5 is due by 2:00 pm, February 15th on Canvas.**  See [here](https://crd150.github.io/hw_guidelines.html) for assignment guidelines.  You must submit an `.Rmd` file and its associated `.html` file. Name the files: yourLastName_firstInitial_asgn05. For example: brazil_n_asgn05.</p>


<div style="margin-bottom:25px;">
</div>
## **Open up a R Markdown file**
\

Download the [Lab template](https://raw.githubusercontent.com/crd150/data/master/labtemplate.Rmd) into an appropriate folder on your hard drive (preferably, a folder named 'Lab 5'), open it in R Studio, and type and run your code there. The template is also located on Canvas under Files.  Change the title ("Lab 5") and insert your name and date. Don't change anything else inside the YAML (the stuff at the top in between the `---`).  Also keep the grey chunk after the YAML. For a rundown on the use of R Markdown, see the [assignment guidelines](https://crd150.github.io/hw_guidelines.html)

<div style="margin-bottom:25px;">
</div>
## **Installing and loading packages**
\

You’ll need to install the following packages in R. You only need to do this once, so if you’ve already installed these packages, skip the code. Also, don’t put these `install.packages()` commands in your R Markdown document. Copy and paste the code in the R Console. We’ll talk about what functions these packages provide as they come up in the guide.

```{r message = FALSE, warning = FALSE, eval=FALSE}
install.packages("sf")
install.packages("tigris")
install.packages("tmap")
install.packages("RColorBrewer")
```

You’ll need to load the following packages using `library()`. Unlike installing, you will always need to load packages whenever you start a new R session. 

```{r message = FALSE, warning=FALSE}
library(tidyverse)
library(tidycensus)
library(flextable)
library(sf)
library(tigris)
library(tmap)
library(RColorBrewer)
```

<div style="margin-bottom:25px;">
</div>
## **Spatial data in R**
\

The main package we will use for handling spatial data in R is the tidy friendly **sf** package.  **sf** stands for simple features.  What is a feature? A feature is thought of as a thing, or an object in the real world, such as a building or a tree.  A county can be a feature. As can a city and a neighborhood.  Features have a geometry describing where on Earth the features are located, and they have attributes, which describe other properties. Think back to [Lab 3](https://crd150.github.io/lab3.html) - we were working with counties.  The difference between what we were doing then and what we will be doing in this lab is that counties in Lab 3 had attributes (e.g. percent Hispanic, total population), but they did not have geometries. As such, we could not put them on a map because we didn't have their specific geographic coordinates. This is what separates nonspatial and spatial data in R.  

<div style="margin-bottom:25px;">
</div>
## **Bringing in spatial data**
\

**sf** is the specific type of data object that deals with spatial information in R. Think back to [Lab 1](https://crd150.github.io/lab1.html#R_Data_Structures) when we discussed the various ways R stores data - **sf** is just another way.  But please note that spatial data themselves outside of R can take on many different formats. We'll be primarily working with shapefiles in this class.  [Shapefiles](https://en.wikipedia.org/wiki/Shapefile) are not the only type of spatial data, but they are the most commonly used. Let's be clear here: **sf** objects are R specific and shapefiles are a general format of spatial data.  This is like tibbles are R specific and csv files are a general format of non spatial data. 

We will be primarily working with census geographic data in this lab and pretty much all future labs. If you need a reminder of the Census geographies, go back to Handout 3. There are two major packages for bringing in Census shapefiles into R: **tidycensus** and **tigris**.  

<div style="margin-bottom:25px;">
</div>
### **tidycensus**
\

In [Lab 3](https://crd150.github.io/lab3.html#Using_the_Census_API), we worked with the **tidycensus** package and the Census API to bring in Census data into R.  Fortunately, we can use the same commands to bring in Census geographic data.  First, load in your Census API key.  If you already installed your API key in a past lab using `install = TRUE` in `census_api_key()`, skip this step.

```{r eval=FALSE, warning=FALSE, results="hide"}
census_api_key("YOUR API KEY GOES HERE", install = TRUE)
```

Then use the `get_acs()` command to bring in California tract-level median household income, total foreign-born population, and total population from the 5-year 2017-2021 American Community Survey (ACS).  Remember that "E" at the end of the variable indicates "Estimate" and "M" indicates margin of errors.

```{r warning=FALSE, results="hide", message=FALSE}
ca.tracts <- get_acs(geography = "tract", 
              year = 2021,
              variables = c(medincome = "B19013_001", 
                            fb = "B05012_003", totp = "B05012_001"), 
              state = "CA",
              survey = "acs5",
              output = "wide",
              geometry = TRUE)
```

The only difference between the code above and what we used in Lab 3 is we have one additional argument added to the `get_acs()` command: `geometry = TRUE`.  This command tells R to bring in the spatial features associated with the geography you specified in the command, in our case California tracts. You can further narrow your geographic scope to the county level by typing in `county =` as an argument.  For example, to get just Sacramento county tracts, you would type in `county = "Sacramento"`. Type in *ca.tracts* to see what we've got.

```{r}
ca.tracts
```

<br>

The object looks much like a basic tibble, but with a few differences.  

* You'll find that the description of the object now indicates that it is a simple feature collection with 8 fields (attributes or columns of data).  There are 9129 features, in this case, census tracts.
* The Geometry Type indicates that the spatial data are in `MULTIPOLYGON` form (as opposed to points or lines, the other basic vector data forms, which were discussed in Handout 5).  
* The Bounding Box indicates the spatial extent of the features (from left to right, for example, California tracts go from a longitude of -124.4096 to -114.1312).  
* Geodetic CRS is related to the coordinate reference system, which we'll touch on later in the quarter.  
* The final difference is that the data frame contains the column *geometry*.  This geometry is what makes this data frame spatial. Remember that a tibble is a data frame. Hence, an **sf** object is basically a tibble, or has tibble like qualities.  This means that we can use nearly all of the functions we've learned in the past three labs on **sf** objects. Hooray for consistency!

We can find out the object's class

```{r}
class(ca.tracts)
```

Here we find that the object is an *sf* data frame. 


<div style="margin-bottom:25px;">
</div> 
### **tigris package**
\

Another package that allows us to bring in census geographic boundaries is **tigris**.  [Here](https://github.com/walkerke/tigris/blob/master/README.md) is a list of all the geographies you can download through this package.  Let's bring in the boundaries for Sacramento city.  Remember from Handout 3 that cities are designated as places by the Census. Use the `places()` function to get all places in California.

```{r warning=FALSE, message=FALSE, results = FALSE}
pl <- places(state = "CA", cb = TRUE, year=2021)
```

<br>

The `cb = TRUE`  argument tells R to download a [generalized cartographic boundary](https://www.census.gov/programs-surveys/geography/technical-documentation/naming-convention/cartographic-boundary-file.html) file, which drastically reduces the size of the data (compare the file size when you don't include `cb = TRUE`).  For example, it eliminates all areas that are strictly covered by water (e.g. lakes).   The argument `year=2021` tells R to bring in the boundaries for that year (census geographies can change from year to year). When using the multi-year ACS, best to use the end year of the period. In the `get_acs()` command above we used `year=2021`, so also use `year=2021` in the `places()` command.  Note that unlike the **tidycensus** package, **tigris** does not allow you to attach attribute data (e.g. Hispanic, total population, etc.) to geometric features.

Take a glimpse of *pl*

```{r}
glimpse(pl)
```

We see a *geometry* column, which indicates we have a spatial data frame.

We can use `filter()` to keep Sacramento city. We will filter on the variable *NAME* to keep Sacramento.

```{r warning=FALSE, message=FALSE, results = FALSE}
sac.city <- filter(pl, NAME == "Sacramento")
```

The argument `NAME == "Sacramento"` tells R to keep cities with the exact city name "Sacramento". Make sure we got what we wanted.

```{r}
glimpse(sac.city)
```


Let's use use the function `counties()` to bring in county boundaries. 

```{r warning=FALSE, message=FALSE, results = FALSE}
cnty <- counties(state = "CA", cb = TRUE, year=2021)
```

Take a look at the data to make sure it contains what we want.

```{r}
glimpse(cnty)
```

To get Sacramento county, we use the `filter()` function. Similar to *pl*, we will filter on the variable *NAME* to keep Sacramento.

```{r}
sac.county <- filter(cnty, NAME == "Sacramento")
```

Guess what? You earned another badge! Yipee!!


<center>
![](/Users/noli/Documents/UCD/teaching/CRD150/Lab/crd150.github.io/tigris_sticker.png){ width=25% }

</center>

<div style="margin-bottom:25px;">
</div> 
### **Reading from your hard drive**
\

Directly reading spatial files using an API is great, but doesn't exist for many spatial data sources. You'll often have to download a spatial data set, save it onto your hard drive and read it into R.  The function for reading spatial files from your hard drive as **sf** objects is `st_read()`.

Let's bring in two shapefiles I created that contains (1) median housing values for census tracts in Sacramento county and (2) Sacramento county [parks](https://data-sacramentocounty.opendata.arcgis.com/datasets/parks-1/explore).  I zipped up the files and uploaded it onto Github. Make sure your current working directory is pointed to the appropriate folder on your hard drive (use `setwd()`). Use the following code to download and unzip the file. 

```{r warning = FALSE, message = FALSE}
download.file(url = "https://raw.githubusercontent.com/crd150/data/master/lab5files.zip", destfile = "lab5files.zip")
unzip(zipfile = "lab5files.zip")
```

<br>

Don't worry if you don't understand these commands - they are more for you to simply copy and paste so that you can download files that I zipped up and uploaded onto Github.  You can look at the help documentation for each function if you are curious.

If you are having problems with the above code, I also uploaded the zip file on Canvas in the Week 5 Lab folder. To manually unzip zipped files on a Mac, check [here](https://support.apple.com/guide/mac-help/zip-and-unzip-files-and-folders-on-mac-mchlp2528/mac). For Windows, check [here](https://support.microsoft.com/en-us/windows/zip-and-unzip-files-f6dde0a7-0fec-8294-e1d3-703ed85e7ebc).

You should see *SacramentoCountyTracts*, *Parks* and *californiatractsrace* files in your current working directory (type in `getwd()` to find where these files reside on your hard drive). Note that the shapefile is actually not a single file but is represented by multiple files. For *SacramentoCountyTracts*, you should see four files named *SacramentoCountyTracts* with shp, dbf, prj, and shx extensions. These files are all connected to one another, so don't manually alter these files. Only open and alter these files in R.  Moreover, if you want to remove a shapefile from your hard drive, delete all the associated files not just one. For *Parks*, you will see five associated files. We will bring in the non-spatial data file *californiatractsrace.csv* a little later.

Make sure your working directory is now pointed to the *lab5files* folder. Then bring in the Sacramento County tract shapefile using the function `st_read()`, which is from the **sf** package.  You'll need to add the *.shp* extension so that the function knows it's reading in a shapefile.

```{r warning = FALSE, message = FALSE, results = "hide"}
sac.county.tracts <- st_read("SacramentoCountyTracts.shp", stringsAsFactors = FALSE)
```

The argument `stringsAsFactors = FALSE` tells R to keep any variables that look like a character as a character and not a [factor](https://r4ds.had.co.nz/factors.html), which we won't use much, if at all, in this class.

Take a look

```{r}
glimpse(sac.county.tracts )
```

Has a *geometry* column, so we know it is spatial. Bring in the parks file.

```{r warning = FALSE, message = FALSE, results = "hide"}
parks <- st_read("Parks.shp", stringsAsFactors = FALSE)
```

Take a look

```{r}
glimpse(parks)
```

<div style="margin-bottom:25px;">
</div>
## **Data Wrangling**
\

There is a lot of stuff [behind the curtain](https://r-spatial.github.io/sf/articles/sf1.html) of how R handles spatial data as simple features, but the main takeaway is that **sf** objects are data frames.  This means you can use many of the functions we've learned in the past couple labs to manipulate **sf** objects, and this includes our best buddy the pipe `%>%` operator.  For example, let's do the following data wrangling tasks on *ca.tracts*.

1. Drop the margins of errors
2. Rename the variables
3. Calculate percent foreign born

We do all of this in one line of continuous code using the pipe operator `%>%`

```{r results='hide'}
ca.tracts <- ca.tracts %>%
            select(-medincomeM, -fbM, -totpM) %>%
            rename(medincome = medincomeE, fb = fbE, totp = totpE) %>%
            mutate(pfb = fb/totp)
```

Notice that we've already used all of the functions above for nonspatial data wrangling. 

Another important operation is to join attribute data to an **sf** object.  For example, let's say you wanted to add tract level percent race/ethnicity, which is located in the *californiatractsrace.csv* file we downloaded earlier. Bring this file in using our familiar friend `read_csv()`.

```{r warning=FALSE, message=FALSE}
ca.race <- read_csv("californiatractsrace.csv")
```

Remember, were dealing with data frames here, so we can use `left_join()`, which we covered in [Lab 3](https://crd150.github.io/lab3.html#Joining_tables), to join the non spatial data frame *ca.race* to the spatial data frame *sac.county.tracts*.

```{r warning=FALSE, message=FALSE}
sac.county.tracts <- sac.county.tracts %>%
  left_join(ca.race, by = "GEOID")
sac.county.tracts
```  

Note that you cannot join two **sf** objects together using `left_join()`. Always use `left_join()` to join a regular non spatial data frame to a spatial object. For example, you will get an error if you try to join the *ca.tracts* to *sac.county.tracts*

```{r, error=TRUE}
sac.county.tracts <- sac.county.tracts %>%
  left_join(ca.tracts, by = "GEOID")
```  

The error message tells you that you can use the function `st_join()` to join two spatial data objects. We'll learn more about `st_join()` in the next lab.

You can also use the exploratory data analysis functions we learned about in [Lab 4](https://crd150.github.io/lab4.html). For example, what is the correlation between median housing value and percent black?

```{r}
sac.county.tracts %>%
  summarize(Correlation = cor(medhval, pnhblk, use = "complete.obs"))
```  

We get the correlation, but it's not quite as clean as when we calculated descriptive statistics in Lab 4. That's because the resulting object after you do `summarize()` is still a spatial object. To coerce it into a non spatial object, use the function `st_drop_geometry()`, which unsurprisingly drops the object's geometry. This way you can use `flextable()` to create presentation ready tables.

```{r}
sac.county.tracts %>%
  summarize(Correlation = cor(medhval, pnhblk, use = "complete.obs")) %>%
  st_drop_geometry() %>%
  flextable()
```  


The main takeaway: **sf** objects are data frames, so you can use many of the functions you've learned in the past couple of labs on these objects.  


<div style="margin-bottom:25px;">
</div>
## **Saving shapefiles**
\

To save an **sf** object to a file, use the function `st_write()` and specify at least two arguments, the **sf** object you want to save and a file name in quotes with the file extension. You'll also need to specify `delete_layer = TRUE` which overwrites the existing file if it already exists in your current working directory.  Make sure you've set your directory to the folder you want your file to be saved in.  Type in `getwd()` to see your current directory and use `setwd()` to set the directory.

Let's save *sac.county.tracts* as a shapefile named *saccountytractslab5.shp*.  

```{r message=FALSE, results = FALSE}
st_write(sac.county.tracts, "saccountytractslab5.shp", delete_layer = TRUE)
```

Check your current working directory to see if the file *saccountytractslab5.shp* was saved.  

You can save your **sf** object in a number of different data formats other than `shp`.  We won't be concerned too much with these other formats in this class, but you can see a list of them [here](https://www.gdal.org/ogr_formats.html).


<div style="margin-bottom:25px;">
</div>
## **Mapping in R**
\

Now that you've got your spatial data in and wrangled, the next natural step is to map something. There are several functions in R that can be used for mapping.  We won't go through all of them, but GWR outlines in Table 9.1 the range of mapping packages available in R.  The package we'll rely on in this class for mapping is **tmap**.

The foundation function for mapping in **tmap** is `tm_shape()`.  You then build on `tm_shape()` by adding one or more elements, all taking on the form of `tm_`.  Let's make a choropleth map of median housing values. 

```{r warning = FALSE, message = FALSE}
tm_shape(sac.county.tracts) +
  tm_polygons(col = "medhval", style = "quantile")
```

You first put the dataset *sac.county.tracts* inside `tm_shape()`. Because you are plotting polygons, you use `tm_polygons()` next. If you are plotting points, you will use `tm_dots()`. If you are plotting lines, you will use `tm_lines()`.  The argument `col = "medhval"` tells R to shade the tracts by the variable *medhval*.  **tmap** allows users to specify the classification style with the `style` argument. The argument `style = "quantile"` tells R to break up the shading into quantiles, or equal groups of 5. Seven of the most useful classification styles are described in the bullet points below (taken from GWR):

* `style = pretty`, the default setting, rounds breaks into whole numbers where possible and spaces them evenly
* `style = equal` divides input values into bins of equal range, and is appropriate for variables with a uniform distribution (not recommended for variables with a skewed distribution as the resulting map may end-up having little color diversity)
* `style = quantile` ensures the same number of observations fall into each category (with the potential down side that bin ranges can vary widely)
* `style = jenks` identifies groups of similar values in the data and maximizes the differences between categories
* `style = cont` (and `order`) present a large number of colors over continuous color field, and are particularly suited for continuous rasters (order can help visualize skewed distributions)
* `style = sd` divides the values by standard deviations above and below the mean.
* `style = cat` was designed to represent categorical values and assures that each category receives a unique color

The importance of choosing the appropriate classification scheme is discussed in Handout 5.  You'll get some practice trying out other classification schemes in this week's assignment. Note that **tmap** is smart enough to detect the presence of missing values, and shades them gray and labels them on the legend.

You can overlay multiple features on one map. For example, we can add park polygons on top of county tracts, providing a visual association between parks and percent white.  Here, we add another `tm_shape()` and `tm_polygons()` to the above code.

```{r warning = FALSE, message = FALSE}
tm_shape(sac.county.tracts) +
  tm_polygons(col = "medhval", style = "quantile") +
  tm_shape(parks) +
    tm_polygons(col = "green")
```


<div style="margin-bottom:25px;">
</div>
### **Color Scheme**
\

Don't like the yellow/brown color scheme? We can change the color scheme using the argument `palette =` within `tm_polygons()`. The argument `palette =` defines the color ranges associated with the bins as determined by the `style` argument.  Below we use the color scheme "Reds" using `style = "quantile"`.

```{r warning = FALSE, message = FALSE}
tm_shape(sac.county.tracts) +
  tm_polygons(col = "medhval", style = "quantile", palette = "Reds") 
```

See Ch. 9.2.4 in GWR for a fuller discussion on color and other schemes you can specify.

In addition to the built-in palettes, customized color ranges can be created by specifying a vector with the desired colors as anchors. This will create a spectrum of colors in the map that range between the colors specified in the vector. For instance, if we used `c(“red”, “blue”)`, the color spectrum would move from red to purple, then to blue, with in between shades. In our example:

```{r warning = FALSE, message = FALSE}
tm_shape(sac.county.tracts) +
  tm_polygons(col = "medhval", style = "quantile",palette =  c("red","blue")) 
```


Not exactly a pretty picture. In order to capture a diverging scale, we insert “white” in between red and blue.

```{r warning = FALSE, message = FALSE}
tm_shape(sac.county.tracts) +
  tm_polygons(col = "medhval", style = "quantile",palette = c("red","white", "blue")) 
```


A preferred approach to select a color palette is to chose one of the schemes contained in the **RColorBrewer** package. These are based on the research of cartographer Cynthia Brewer (see the colorbrewer2 [web site](https://colorbrewer2.org/#type=sequential&scheme=BuGn&n=3) for details). **RColorBrewer** makes a distinction between sequential scales (for a scale that goes from low to high), diverging scales (to highlight how values differ from a central tendency), and qualitative scales (for categorical variables). For each scale, a series of single hue and multi-hue scales are suggested. In the **RColorBrewer** package, these are referred to by a name (e.g., the “Reds” palette we used above is an example). The full list is contained in the **RColorBrewer** [documentation](https://www.rdocumentation.org/packages/RColorBrewer/versions/1.1-2/topics/RColorBrewer).

There are two very useful commands in this package. One sets a color palette by specifying its name and the number of desired categories. The result is a character vector with the hex codes of the corresponding colors.

For example, we select a sequential color scheme going from blue to green, as *BuGn*, by means of the command `brewer.pal`, with the number of categories (6) and the scheme as arguments. The resulting vector contains the HEX codes for the colors.

```{r}
pal <- brewer.pal(6,"BuGn")
pal
```

Using this palette in our map yields the following result.

```{r warning = FALSE, message = FALSE}
tm_shape(sac.county.tracts) +
  tm_polygons(col = "medhval", style = "quantile", palette="BuGn") 
```

The command `display.brewer.pal()` allows us to explore different color schemes before applying them to a map. For example:

```{r}
display.brewer.pal(6,"BuGn")
```



<div style="margin-bottom:25px;">
</div>
### **Legend**
\

There are many options to change the formatting of the legend. Often, the automatic title for the legend is not intuitive, since it is simply the variable name (in our case, *medhval*). This can be customized by setting the `title` argument in `tm_polygons()`.  Let's change the legend title to "Housing values"

```{r warning = FALSE, message = FALSE}
tm_shape(sac.county.tracts) +
  tm_polygons(col = "medhval", style = "quantile",palette = "Reds", 
              title = "Housing values") 
```

Another important aspect of the legend is its positioning. This is handled through the `tm_layout()` function. This function has a vast number of options, as detailed in the [documentation](https://www.rdocumentation.org/packages/tmap/versions/2.1-1/topics/tm_layout).  Also check the help documentation for `tm_layout()` to see the complete list of settings and examples in Ch. 9.2.5 in GWR.  There are also specialized subsets of layout functions, focused on specific aspects of the map, such as `tm_legend()`, `tm_style()` and `tm_format()`. We illustrate the positioning of the legend.

The default is to position the legend inside the map. Often, this default solution is appropriate, but sometimes further control is needed.  The `legend.position` argument in the `tm_layout()` function moves the legend around the map, and it takes on a vector of two string variables that determine both the horizontal position (“left”, “right”, or “center”) and the vertical position (“top”, “bottom”, or “center”).  The default is "right" and "bottom".  But, we can change it to, say, top right.

```{r warning = FALSE, message = FALSE}
tm_shape(sac.county.tracts) +
  tm_polygons(col = "medhval", style = "quantile",palette = "Reds",
              title = "Housing values") +
  tm_layout(legend.position =  c("right", "top"))
```

Yuck.  We can leave it at the bottom right. Or there is also the option to position the legend outside the frame of the map. This is accomplished by setting `legend.outside` to TRUE (the default is FALSE) in `tm_layout()`.  

```{r warning = FALSE, message = FALSE}
tm_shape(sac.county.tracts) +
  tm_polygons(col = "medhval", style = "quantile",palette = "Reds", 
              title = "Housing values") +
    tm_layout(legend.outside = TRUE)
```

We can also customize the size of the legend, its alignment, font, etc. We refer to GWR for specifics.

<div style="margin-bottom:25px;">
</div>
### **Title**
\


Another functionality of the `tm_layout()` function is to set a title for the map, and specify its position, size, etc. For example, we can set the title using `main.title`, and the size using `main.title.size` as in the example below. We made the font size a bit smaller (0.95) in order not to overwhelm the map.


```{r warning = FALSE, message = FALSE}
tm_shape(sac.county.tracts) +
  tm_polygons(col = "medhval", style = "quantile",palette = "Reds",
              title = "Housing values") +
    tm_layout(main.title = "2017-21 Median Housing Values in Sacramento County",
              main.title.size = 0.95, legend.outside = TRUE)
```

You can change the title position using `main.title.position`.  For example, we center the title by specifying "center".

```{r warning = FALSE, message = FALSE}
tm_shape(sac.county.tracts) +
  tm_polygons(col = "medhval", style = "quantile",palette = "Reds",
              title = "Housing values") +
    tm_layout(main.title = "2015-19 Median Housing Values in Sacramento County",
              main.title.size = 0.95, main.title.position="center", 
              legend.outside = TRUE)
```

  
<div style="margin-bottom:25px;">
</div>
### **Scale bar and arrow**
\

We need to add the other key map elements described in Handout 5. Here is where we start adding more layout functions after `tm_polygons()` using the `+` operator.  First, the scale bar, which you can add using the function `tm_scale_bar()`

```{r warning = FALSE, message = FALSE}
tm_shape(sac.county.tracts, unit = "mi") +
tm_polygons(col = "medhval", style = "quantile",palette = "Reds",
              title = "Housing values") +
    tm_layout(main.title = "2015-19 Median Housing Values in Sacramento County",
              main.title.size = 0.95, main.title.position="center", 
              legend.outside = TRUE) +
  tm_scale_bar(breaks = c(0, 5, 10), text.size  = 0.75, 
               position = c("right", "bottom")) 
```

The argument `breaks` within `tm_scale_bar()` tells R the distances to break up and end the bar.  Make sure you use reasonable break points - the Sacramento county area is not, for example, 200 miles wide, so you should not use `c(0,100,200)` (try it and see what happens. You won't like it). Note that the scale is in miles (were in America!).  The default is in kilometers (the rest of the world!), but you can specify the units within `tm_shape()` using the argument `unit`.  Here, we used `unit = "mi"` to designate distance in the scale bar measured in miles.  The `position =` argument locates the scale bar on the bottom right of the map. The argument `text.size  =` controls the size of the scale bar.  We decrease the size  by 25%.

<br>

The next element is the north arrow, which we can add using the function `tm_compass()`.  You can control for the type, size and location of the arrow within this function.  We place a 4-star arrow on the top left of the map.

```{r warning = FALSE, message = FALSE}
tm_shape(sac.county.tracts, unit = "mi") +
tm_polygons(col = "medhval", style = "quantile",palette = "Reds",
              title = "Housing values") +
    tm_layout(main.title = "2015-19 Median Housing Values in Sacramento County",
              main.title.size = 0.95, main.title.position="center", 
              legend.outside = TRUE) +
  tm_scale_bar(breaks = c(0, 5, 10), text.size  = 0.75, 
               position = c("right", "bottom"))  +
  tm_compass(type = "4star", position = c("left", "top")) 
```

<div style="margin-bottom:25px;">
</div>
### **Other features**
\

We can make the map *prettier* by changing a variety of settings. We can eliminate the frame around the map using the argument `frame = FALSE` with `tm_layout`.  We also add back the parks.


```{r warning = FALSE, message = FALSE}
sac.map <- tm_shape(sac.county.tracts, unit = "mi") +
tm_polygons(col = "medhval", style = "quantile",palette = "Reds",
              title = "Housing values") +
    tm_layout(main.title = "2015-19 Median Housing Values in Sacramento County",
              main.title.size = 0.95, main.title.position="center", 
              legend.outside = TRUE, frame = FALSE, ) +
  tm_scale_bar(breaks = c(0, 5, 10), text.size  = 0.75, 
               position = c("right", "bottom"))  +
  tm_compass(type = "4star", position = c("left", "top")) +  
  tm_shape(parks) +
    tm_polygons(col = "green")

sac.map
```


Notice that we stored the map into an object called *sac.map*.  R is an object-oriented language, so *everything* you *make* in R are objects that can be stored for future manipulation.  This includes maps.  You should see *sac.map* in your Environment window. By storing the map, you can access it anytime during your current R session.

Check the full list of `tm_` elements [here](https://www.rdocumentation.org/packages/tmap/versions/2.0/topics/tmap-element).


<div style="margin-bottom:25px;">
</div>    
### **Saving maps**
\

You can save your maps a couple of ways.

1. On the plotting screen where the map is shown, click on *Export* and save it as either an image or pdf file.
2. Use the function `tmap_save()`

For option 2, we can save the map object *sac.map* as such 

```{r warning=FALSE, message=FALSE, eval = FALSE}
tmap_save(sac.map, "saccountyhval.png")
```

Specify the **tmap** object and a filename with an extension. It supports `pdf`, `eps`, `svg`, `wmf`, `png`, `jpg`, `bmp` and `tiff`.  The default is `png`.  Also make sure you've set your directory to the folder that you want your map to be saved in.  

<div style="margin-bottom:25px;">
</div>
### **Interactive maps**
\

So far we've created static maps. That is, maps that don't "move".  But, we're all likely used to Google or Bing maps - maps that we can move around and zoom into.  You can make interactive maps in R using the package **tmap**.  

To make your **tmap** object interactive, use the function `tmap_mode()`. Type in "view" inside this function.

```{r, warning = FALSE, message = FALSE}
tmap_mode("view")
```

Now that the interactive mode has been ‘turned on’, all maps produced with `tm_shape()` will launch. Let's view our saved *sac.map* interactively.

```{r, warning = FALSE, message = FALSE}
sac.map
```

Click on ![](/Users/noli/Documents/UCD/teaching/CRD150/Lab/crd150.github.io/zoom.png) above the map and a larger window should open up. 

Besides interactivity, another important benefit of `tmap_mode()` is that it provides a basemap, which was discussed in Handout 5.  The function of a basemap is to provide background detail necessary to orient the location of the map.  In the static maps we produced earlier, Sacramento county was sort of floating in white space.  As you can see in the interactive map above we've added geographic context to the surrounding area. 

The default basemap in `tmap_mode()` is CartoDB.Positron.  You can change the basemap through the `tm_basemap()` function.  For example, let's change the basemap to an [OpenStreetMap](https://www.openstreetmap.org/).

```{r warning=FALSE, message=FALSE}
sac.map + tm_basemap("OpenStreetMap")
```

For a complete list of basemaps with previews, see [here](http://leaflet-extras.github.io/leaflet-providers/preview/).  There are a lot of cool ones, so please test them out.

You can save your interactive map using the same methods described for static maps. To switch back to plotting mode (noninteractive), type in 

```{r}
tmap_mode("plot")
```

You've completed your introduction to **sf**. Whew! Badge? Yes, please, you earned it!  Time to [celebrate](https://www.youtube.com/watch?v=3GwjfUFyY6M)!

<center>
![](/Users/noli/Documents/UCD/teaching/CRD150/Lab/crd150.github.io/sf.gif){ width=25% }

</center>


<div style="margin-bottom:25px;">
</div>
## **Assignment 5**
\

Download and open the [Assignment 5 R Markdown Script](https://raw.githubusercontent.com/crd150/data/master/yourLastName_firstInitial_asgn05.Rmd). The script can also be found on Canvas (Files - Week 5 - Assignment). Any response requiring a data analysis task  must be supported by code you generate to produce your result. Just examining your various objects in the “Environment” section of R Studio is insufficient—you must use scripted commands. Submit the `Rmd` and its knitted `html` files on Canvas.

<br>

1. CalEnviroScreen is a mapping tool that helps identify California communities that are most affected by many sources of pollution, and where people are often especially vulnerable to pollution's effects. Download the CalEnviroScreen California tract-level shapefile from the the [official CES website](https://oehha.ca.gov/media/downloads/calenviroscreen/document/calenviroscreen40shpf2021shp.zip). The file is also located on Canvas in the Week 5 Assignment folder. Make sure to download it in an appropriate folder on your hard drive. Unzip the folder. 

a. Read the file into R and keep tracts in Yolo county. (1 point)
b. Make a static presentation-ready map of the variable *PM2_5* for Yolo county tracts, which is the level of pollution based on PM 2.5 levels (higher PM 2.5, more pollution), using quantile breaks. Summarize in your own words the geographic distribution of pollution burden in Yolo county based on the map. (2 points)
c. Produce static maps of *PM2_5* using three other classifications other than quantile breaks. Does your general impression of where high and low pollution burden neighborhoods are located in the county change across the different classifications? (6 points)

2. We are gradually receding from a global health crisis marked by profound human suffering. Analyzing the demographic, health and job characteristics of communities reveals that some places were disproportionately affected by this suffering. In particular, we found that communities with no or unstable internet access are at a disadvantage given that employment, medical care (telemedicine), education and other important services were and still are primarily conducted online at home. Let's visually examine the association between internet access and race/ethnicity in Sacramento county census tracts.

a. Using the Census API, bring in 2017-2021 total, non-Hispanic white, non-Hispanic black, non-Hispanic Asian, and Hispanic populations for census tracts in Sacramento county.  Check Lab 3 for the appropriate variable IDs. Make sure to bring in spatial data by using `geometry = TRUE`. Calculate the percent Asian, white, black and Hispanic variables. (2 points)
b. Bring into R the 2017-2021 percent of households without a cable, Fiber Optic, or DSL internet connection for Sacramento county census tracts from PolicyMap (from the PolicyMap site, click on Quality of Life, Computer and Internet Access, Household Internet Access, Without High Speed Internet Access, and No Cable, Fiber Optic or DSL). Make sure to clean the data. (1 point)
c. Merge the percent of households without a broadband, cable, Fiber Optic, or DSL internet connection to the **sf** census tracts object you created in (a). (1 point)
d. Create presentation-ready maps of percent non-Hispanic black, non-Hispanic white, non-Hispanic Asian, and Hispanic using quantile breaks.  (4 points)
e. Create a map of the percent of households without a broadband, cable, Fiber Optic, or DSL internet connection using quantile breaks. (1 point)
f. Based on a visual comparison of the maps you created in (d) and (e), summarize in your own words the association between racial/ethnic composition and percent of households without a broadband, cable, Fiber Optic, or DSL internet connection. (2 points)

***


<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.


Website created and maintained by [Noli Brazil](https://nbrazil.faculty.ucdavis.edu/)